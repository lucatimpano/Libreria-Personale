

// ---- Inizio: ./db/BookManager.java ----
package gestore_libreria.db;

import gestore_libreria.model.Book;
import gestore_libreria.model.SortCriteria;

import java.util.List;

// Questa è ora un'INTERFACCIA
public interface BookManager {

    void addBook(Book book);

    List<Book> getAllBook(SortCriteria criteria);

    List<Book> findBookByTitle(String title, SortCriteria criteria);

    List<Book> filterBookByRating(int rating, SortCriteria criteria);

    List<Book> filterBookByReadingState(String readingState, SortCriteria criteria);

    List<Book> findBookByAuthor(String author, SortCriteria criteria);

    void updateBook(Book oldBook, Book book);

    void deleteBook(Book book);

}
// ---- Fine: ./db/BookManager.java ----


// ---- Inizio: ./db/ConcreteBookManager.java ----
package gestore_libreria.db;

import gestore_libreria.memento.BookHistoryManager;
import gestore_libreria.memento.BookMemento;
import gestore_libreria.model.Book;
import gestore_libreria.model.SortCriteria;
import gestore_libreria.observer.BookObserver;
import gestore_libreria.observer.Subject;

import java.util.List;

// Questa classe ora implementa l'interfaccia BookManager.
public class ConcreteBookManager extends Subject implements BookManager, BookHistoryManager.OnMementoListener  {

    private final BookRepositoryImplementor repository;
    private final BookHistoryManager historyManager;

    /**
     * Costruisce una nuova istanza di ConcreteBookManager.
     *
     * @param repository L'implementazione del repository per la gestione dei dati dei libri.
     * @pre repository non deve essere null.
     * @post L'oggetto ConcreteBookManager è stato inizializzato.
     * @post Il repository interno è stato impostato con l'istanza fornita.
     * @post Viene creata una nuova istanza di BookHistoryManager.
     * @post L'istanza corrente di ConcreteBookManager è registrata come listener per il ripristino dei memento nella cronologia.
     */
    public ConcreteBookManager(BookRepositoryImplementor repository) {
        this.repository = repository;
        this.historyManager = new BookHistoryManager();
        this.historyManager.setOnMementoRestoreListener(this);
    }

    /**
     * Restituisce l'istanza del gestore della cronologia (BookHistoryManager) associata a questo manager.
     *
     * @pre Nessuna pre-condizione specifica. Il manager deve essere stato inizializzato (il costruttore deve essere stato chiamato).
     * @post Restituisce un'istanza non null di BookHistoryManager.
     * @return L'istanza di {@code BookHistoryManager}.
     */
    public BookHistoryManager getHistoryManager() {
        return historyManager;
    }

    /**
     * Consente l'inserimento di un libro nel database
     *
     * @param book Il libro da aggiungere.
     * @pre book non deve essere null.
     * @pre book.getTitle() non deve essere null o vuoto.
     * @pre book.getAuthor() non deve essere null o vuoto.
     * @post Il libro è stato correttamente inserito nel database con codice ID univoco.
     * @post Dopo l'inserimento vengono notificati gli Observer.
     * @post Dopo l'inserimento si salva il libro nello stack hystoryManager.
     */
    @Override
    public void addBook(Book book) {
        repository.save(book);
        historyManager.save(new BookMemento(book, BookMemento.OperationType.ADD));
        super.notifyObservers();
    }

    /**
     * @pre il database deve essere in uno stato consistente.
     * @post Restituisce una lista non null di oggetti Book contenuti nel database.
     * @post Restituisce una lista vuota se il database non contiene nessun oggetto Book.
     * @return Una {@code List<Book>} contenente i libri contenuti nel database.
     */
    @Override
    public List<Book> getAllBook(SortCriteria criteria) {
        return repository.loadAll(criteria);
    }

    /**
     * Permette di trovare i libri che all'interno del titolo contengono la stringa specificata
     *
     * @param title Stringa da cercare nel titolo dei libri.
     * @pre title non deve essere null.
     * @post Restituisce una lista non null di oggetti Book che corrispondono al criterio di ricerca.
     * @post Se nessun libro rispetto il criterio viene restituita una lista vuota.
     * @return Una {@code List<Book>} contenente i libri trovati.
     */
    @Override
    public List<Book> findBookByTitle(String title, SortCriteria criteria) {
        return repository.findByTitle(title, criteria);
    }

    /**
     * Permette di trovare i libri in base alla valutazione specificata
     *
     * @param rating La valutazione come parametro di ricerca (int)
     * @pre rating deve essere un valore intero compreso da 1 a 5
     * @post restituisce una lista non null di oggetti Book che corrispondono al criterio di ricerca
     * @post Se nessun libro rispetto il criterio viene restituita una lista vuota
     * @return Una {@code List<Book>} contenente i libri trovati
     */
    @Override
    public List<Book> filterBookByRating(int rating, SortCriteria criteria) {
        return repository.findByRating(rating, criteria);
    }

    /**
     *Filtra i libri in base allo stato di lettura specificato.
     *
     * @param readingState lo stato di lettura da filtrare (es. "LETTO", "IN LETTURA", "DA LEGGERE")
     * @pre readingState non deve essere null o vuoto
     * @pre readingState deve corrispondere obbligatoriamente a uno degli stati di lettura predefiniti ("LETTO", "IN LETTURA", "DA LEGGERE")
     * @post restituisce una lista non null di oggetti Book che hanno lo stato di lettura specificato
     * @post Se nessun libro rispetto il criterio viene restituita una lista vuota
     * @return Una {@code List<Book>} contenente i libri con lo stato di lettura specificato.
     */
    @Override
    public List<Book> filterBookByReadingState(String readingState, SortCriteria criteria) {
        return repository.findByReadingState(readingState, criteria);
    }

    /**
     * Trova i libri il cui autore contiene la stringa specificata (case-insensitive).
     *
     * @param author La stringa da cercare nel nome dell'autore dei libri.
     * @pre author non deve essere null.
     * @post Restituisce una lista non null di oggetti Book che corrispondono al criterio di ricerca.
     * @post Se nessun libro corrisponde al criterio, la lista restituita è vuota.
     * @return Una {@code List<Book>} contenente i libri trovati.
     */
    @Override
    public List<Book> findBookByAuthor(String author, SortCriteria criteria) {
        return repository.findByAuthor(author, criteria);
    }

    /**
     * Aggiorna un libro esistente nel database e ne salva lo stato per le operazioni di undo/redo.
     *
     * @param oldBook Lo stato precedente del libro prima dell'aggiornamento. Usato per l'undo.
     * @param book Il libro con i dati aggiornati.
     * @pre oldBook non deve essere null.
     * @pre newBook non deve essere null.
     * @pre newBook.getId() deve corrispondere all'ID di un libro esistente nel database.
     * @pre newBook.getTitle() non deve essere null o vuoto.
     * @pre newBook.getAuthor() non deve essere null o vuoto.
     * @post Lo stato del libro nel database è aggiornato con i dati di {@code newBook}.
     * @post Un memento di tipo UPDATE è salvato nella cronologia, contenente sia {@code newBook} che {@code oldBook}.
     * @post Tutti gli osservatori sono notificati del cambiamento.
     *
     */
    @Override
    public void updateBook(Book oldBook, Book book) {
        historyManager.save(new BookMemento(book, BookMemento.OperationType.UPDATE, oldBook));
        repository.update(book);
        super.notifyObservers();
    }

    /**
     * Elimina un libro dal database e ne salva lo stato per le operazioni di undo/redo.
     *
     * @param book Il libro da eliminare.
     * @pre book non deve essere null.
     * @pre book.getId() deve corrispondere all'ID di un libro esistente nel database.
     * @post Il libro è rimosso dal database.
     * @post Un memento di tipo REMOVE è salvato nella cronologia, contenente lo stato del libro prima della rimozione.
     * @post Tutti gli osservatori sono notificati del cambiamento.
     */
    @Override
    public void deleteBook(Book book) {
        historyManager.save(new BookMemento(book, BookMemento.OperationType.REMOVE));
        repository.delete(book);
        super.notifyObservers();
    }

/**
 * Ripristina lo stato di un'operazione del libro in base al memento e alla direzione specificata.
 * Questo metodo gestisce le operazioni di Undo e Redo per aggiunte, rimozioni e aggiornamenti.
 *
 * @param memento Il memento che contiene lo stato del libro e il tipo di operazione.
 * @param direction La direzione dell'azione (UNDO o REDO).
 * @pre memento non deve essere null.
 * @pre memento.getBookState() non deve essere null per le operazioni ADD e REMOVE.
 * @pre memento.getPreviousBookState() non deve essere null per l'operazione UPDATE in caso di UNDO.
 * @post Il database viene modificato per riflettere lo stato del libro come specificato dal memento e dalla direzione.
 * @post Se l'operazione è un UNDO di ADD, il libro viene rimosso.
 * @post Se l'operazione è un REDO di ADD, il libro viene riaggiunto.
 * @post Se l'operazione è un UNDO di REMOVE, il libro viene riaggiunto.
 * @post Se l'operazione è un REDO di REMOVE, il libro viene rimosso.
 * @post Se l'operazione è un UNDO di UPDATE, il libro viene ripristinato allo stato precedente.
 * @post Se l'operazione è un REDO di UPDATE, il libro viene ripristinato allo stato successivo.
 * @post Tutti gli osservatori sono notificati del cambiamento dopo il ripristino.
 */
    @Override
    public void restore(BookMemento memento, BookHistoryManager.ActionDirection direction) {
        switch (memento.getOperationType()) {
            case ADD:
                if (direction == BookHistoryManager.ActionDirection.UNDO) {
                    repository.delete(memento.getBookState());
                    System.out.println("Undo ADD: Rimosso libro " + memento.getBookState().getTitle());
                } else {
                    repository.save(memento.getBookState());
                    System.out.println("Redo ADD: Riaggiunto libro " + memento.getBookState().getTitle());
                }
                break;
            case REMOVE:
                if (direction == BookHistoryManager.ActionDirection.UNDO) {
                    repository.save(memento.getBookState());
                    System.out.println("Undo DELETE: Riaggiunto libro " + memento.getBookState().getTitle());
                } else {
                    repository.delete(memento.getBookState());
                    System.out.println("Redo DELETE: Rimosso libro " + memento.getBookState().getTitle());
                }
                break;
            case UPDATE:
                if (direction == BookHistoryManager.ActionDirection.UNDO) {
                    repository.update(memento.getPreviousBookState());
                    System.out.println("Undo UPDATE: Ripristinato libro " + memento.getPreviousBookState().getTitle() + " allo stato precedente.");
                } else {
                    repository.update(memento.getBookState());
                    System.out.println("Redo UPDATE: Ripristinato libro " + memento.getBookState().getTitle() + " allo stato successivo.");
                }
                break;
        }
        super.notifyObservers(); // Notifica la UI dopo il ripristino
    }
}
// ---- Fine: ./db/ConcreteBookManager.java ----


// ---- Inizio: ./db/DatabaseConnectionSingleton.java ----
package gestore_libreria.db;

import java.sql.*;

public final class DatabaseConnectionSingleton {

    //Riutilizzo la stessa connessione al database, ed evito di aprire una connessione per ogni query che eseguo

    private static final String url = "jdbc:sqlite:Books_db.db";
    private static Connection instance;

    //costruttore privato
    private DatabaseConnectionSingleton(){}

    public static synchronized Connection getInstance() throws SQLException{
        if (instance == null || instance.isClosed()){
            instance = DriverManager.getConnection(url);
        }
        return instance;
    }

    public static void closeConnection() {
        if (instance != null) {
            try {
                instance.close();
                instance = null; // Impostiamo a null per permettere la riapertura
                System.out.println("Connessione al database chiusa.");
            } catch (SQLException e) {
                System.err.println("Errore durante la chiusura della connessione al database: " + e.getMessage());
            }
        }
    }
}

// ---- Fine: ./db/DatabaseConnectionSingleton.java ----


// ---- Inizio: ./db/SQLiteBookRepository.java ----
package gestore_libreria.db;

import gestore_libreria.model.Book;
import gestore_libreria.model.SortCriteria;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

//classe che implementa il database
public class SQLiteBookRepository implements BookRepositoryImplementor {

    protected Connection getConnection() throws SQLException {
        return DatabaseConnectionSingleton.getInstance();
    }

    public SQLiteBookRepository(){
        try{
            Connection connection = getConnection();
            Statement statement = connection.createStatement();
            //aggiungo un id come chiave del libro
            String createTable = """
                    CREATE TABLE IF NOT EXISTS books(
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        title TEXT NOT NULL,
                        author TEXT NOT NULL,
                        isbn TEXT,
                        genre TEXT,
                        rating INTEGER,
                        readingState TEXT,
                        coverPath TEXT
                        );
                    """;
            statement.execute(createTable);
        } catch (SQLException e) {
            System.err.println(e.getMessage());
        }
    }


    @Override
    public void save(Book book) {
        //Per inserire il libro preparo la stringa sql con gli elementi da aggiungere seguiti da ? per ogni parametro
        String sql = """
                INSERT INTO books (title, author, isbn, genre, rating, readingState, coverPath)
                VALUES (?,?,?,?,?,?,?)
                """;
        try{
            Connection connection = getConnection();
            PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            preparedStatement.setString(1, book.getTitle());
            preparedStatement.setString(2,book.getAuthor());
            preparedStatement.setString(3,book.getIsbn());
            preparedStatement.setString(4,book.getGenre());
            preparedStatement.setInt(5,book.getRating());
            preparedStatement.setString(6, book.getReadingState());
            preparedStatement.setString(7,book.getCoverPath());
            preparedStatement.executeUpdate();

            //ricavo il codice del libro e lo inserisco nell'oggetto
            try{
                ResultSet resultSet = preparedStatement.getGeneratedKeys();
                if(resultSet.next()){
                    book.setId(resultSet.getInt(1));
                }
            } catch (SQLException e) {
                System.err.println("Errore nel salvataggio del libro");
                e.printStackTrace();
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private String getOrderByCriteria(SortCriteria criteria){
        if(criteria == null || criteria == SortCriteria.NONE){
            return "";
        }
        switch (criteria){
            case TITLE_ASC:
                return " ORDER BY LOWER(title) ASC";
            case TITLE_DESC:
                return " ORDER BY LOWER(title) DESC";
            case AUTHOR_ASC:
                return " ORDER BY LOWER(author) ASC";
            case AUTHOR_DESC:
                return " ORDER BY LOWER(author) DESC";
            case RATING_ASC:
                return " ORDER BY rating ASC, LOWER(title) ASC";
            case RATING_DESC:
                return " ORDER BY rating DESC, LOWER(title) ASC";
            default:
                return "";
        }
    }

    @Override
    public List<Book> loadAll(SortCriteria criteria) {
        List<Book> books = new ArrayList<>();
        String sql = "SELECT * FROM books" + getOrderByCriteria(criteria);
        System.out.println(sql);

        try{
            Connection connection = getConnection();
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery(sql);

            while (resultSet.next()){

                Book book = new Book.Builder(resultSet.getString("title"), resultSet.getString("author"))
                        .id(resultSet.getInt("id"))
                        .isbn(resultSet.getString("isbn"))
                        .genre(resultSet.getString("genre"))
                        .rating(resultSet.getInt("rating"))
                        .readingState(resultSet.getString("readingState"))
                        .coverPath(resultSet.getString("coverPath"))
                        .build();
                books.add(book);
            }
        } catch (SQLException e) {
            System.err.println(e.getMessage());
        }
        return books;
    }

    @Override
    public List<Book> findByTitle(String title, SortCriteria criteria) {
        List<Book> books = new ArrayList<>();
        String sql = "SELECT * FROM books WHERE LOWER(title) LIKE LOWER(?)" + getOrderByCriteria(criteria);
        try{
            Connection connection = getConnection();
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1, "%" + title + "%");
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()){
                Book book = new Book.Builder(resultSet.getString("title"), resultSet.getString("author"))
                        .id(resultSet.getInt("id"))
                        .isbn(resultSet.getString("isbn"))
                        .genre(resultSet.getString("genre"))
                        .rating(resultSet.getInt("rating"))
                        .readingState(resultSet.getString("readingState"))
                        .coverPath(resultSet.getString("coverPath"))
                        .build();
                books.add(book);
            }
        } catch (SQLException e) {
            System.err.println("Errore nella ricerca del libro dal titolo" + e.getMessage());
        }
        return books;
    }

    @Override
    public List<Book> findByRating(int rating, SortCriteria criteria) {
        List<Book> books = new ArrayList<>();
        String sql = "SELECT * FROM books WHERE rating = ?" + getOrderByCriteria(criteria);
        try{
            Connection connection = getConnection();
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1,rating);
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()){
                Book book = new Book.Builder(resultSet.getString("title"), resultSet.getString("author"))
                        .id(resultSet.getInt("id"))
                        .isbn(resultSet.getString("isbn"))
                        .genre(resultSet.getString("genre"))
                        .rating(resultSet.getInt("rating"))
                        .readingState(resultSet.getString("readingState"))
                        .coverPath(resultSet.getString("coverPath"))
                        .build();
                books.add(book);
            }
        } catch (SQLException e) {
            System.err.println("Errore nella ricerca del libro dalla valutazione");
        }
        return books;
    }

    @Override
    public List<Book> findByReadingState(String readingState, SortCriteria criteria) {
        List<Book> books = new ArrayList<>();
        String sql = "SELECT * FROM books WHERE LOWER(readingState) LIKE LOWER(?)" + getOrderByCriteria(criteria);
        try{
            Connection connection = getConnection();
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1, "%" + readingState + "%");
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()){
                Book book = new Book.Builder(resultSet.getString("title"), resultSet.getString("author"))
                        .id(resultSet.getInt("id"))
                        .isbn(resultSet.getString("isbn"))
                        .genre(resultSet.getString("genre"))
                        .rating(resultSet.getInt("rating"))
                        .readingState(resultSet.getString("readingState"))
                        .coverPath(resultSet.getString("coverPath"))
                        .build();
                books.add(book);
            }
        } catch (SQLException e) {
            System.err.println("Errore nella ricerca del libro dallo stato di lettura");
        }
        return books;
    }

    @Override
    public List<Book> findByAuthor(String author, SortCriteria criteria) {
        List<Book> books = new ArrayList<>();
        String sql = "SELECT * FROM books WHERE LOWER(author) LIKE LOWER(?)" + getOrderByCriteria(criteria);
        try{
            Connection connection = getConnection();
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1, "%" + author + "%");
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()){
                Book book = new Book.Builder(resultSet.getString("title"), resultSet.getString("author"))
                        .id(resultSet.getInt("id"))
                        .isbn(resultSet.getString("isbn"))
                        .genre(resultSet.getString("genre"))
                        .rating(resultSet.getInt("rating"))
                        .readingState(resultSet.getString("readingState"))
                        .coverPath(resultSet.getString("coverPath"))
                        .build();
                books.add(book);
            }
        } catch (SQLException e) {
            System.err.println("Errore nella ricerca del libro dall'autore");
        }
        return books;
    }

    @Override
    public void delete(Book book) {
        int id = book.getId();
        String sql = "Delete FROM books WHERE id = ?";
        try{
            Connection connection = getConnection();
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, id);
            int deleteRow = preparedStatement.executeUpdate();
            if(deleteRow>0){
                System.out.println("Riga eliminata con successo");
            }else {
                System.out.println("Riga NON eliminata con successo");
            }

        } catch (SQLException e) {
            System.err.println("Errore nell'aggiornamento del libro");
            e.printStackTrace();
        }
    }

    @Override
    public void update(Book book) {
        String sql = """
                UPDATE books SET
                title=?,
                author=?,
                isbn=?,
                genre=?,
                rating=?,
                readingState=?,
                coverPath=?
                WHERE id=?
                """;
        try{
            Connection connection = getConnection();
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1, book.getTitle());
            preparedStatement.setString(2, book.getAuthor());
            preparedStatement.setString(3, book.getIsbn());
            preparedStatement.setString(4, book.getGenre());
            preparedStatement.setInt(5, book.getRating());
            preparedStatement.setString(6, book.getReadingState());
            preparedStatement.setString(7, book.getCoverPath());
            preparedStatement.setInt(8, book.getId());      //il libro aggiornato deve avere lo stesso id del libro da modificare

            int affectedRows = preparedStatement.executeUpdate();

        } catch (SQLException e) {
            System.err.println("Errore nell'aggiornamento del libro");
            e.printStackTrace();
        }

    }


//    public static void main(String[] args) {
//        SQLiteBookRepository repo = new SQLiteBookRepository();
//
//        // Pulizia iniziale del database
//        try (Connection conn = DatabaseConnectionSingleton.getInstance();
//             Statement stmt = conn.createStatement()) {
//            stmt.execute("DELETE FROM books");
//            System.out.println("DB pulito.");
//        } catch (SQLException e) {
//            System.err.println("Errore nella pulizia: " + e.getMessage());
//        }
//
//        // Inserisco un libro
//        Book libro = new Book.Builder("Il Signore degli Anelli", "J.R.R. Tolkien")
//                .isbn("978-0544003415")
//                .genre("Fantasy")
//                .rating(5)
//                .readingState("letto")
//                .build();
//
//        repo.save(libro);
//        System.out.println("Libro inserito: " + libro);
//
//        // Modifico lo stesso libro
//        Book modificato = new Book.Builder("Il Signore degli Anelli - Edizione Estesa", libro.getAuthor())
//                .id(libro.getId())
//                .isbn("978-0544003415")
//                .genre("Fantasy Epico")
//                .rating(5)
//                .readingState("letto")
//                .build();
//
//        repo.update(modificato);
//        System.out.println("Libro aggiornato.");
//
//        // Carico tutti i libri e li stampo
//        List<Book> libri = repo.loadAll();
//        libri.forEach(System.out::println);
//    }


}

// ---- Fine: ./db/SQLiteBookRepository.java ----


// ---- Inizio: ./db/BookRepositoryImplementor.java ----
package gestore_libreria.db;

import java.util.List;

import gestore_libreria.model.Book;
import gestore_libreria.model.SortCriteria;


public interface BookRepositoryImplementor {

    //definisco i metodi che devono essere presenti nei database concreti

    void save(Book book);
    List<Book> loadAll(SortCriteria criteria);
    List<Book> findByTitle(String title, SortCriteria criteria);
    List<Book> findByRating(int rating, SortCriteria criteria);
    List<Book> findByReadingState(String readingState, SortCriteria criteria);
    List<Book> findByAuthor(String author, SortCriteria criteria);
    void delete(Book book);
    void update(Book book);
}

// ---- Fine: ./db/BookRepositoryImplementor.java ----


// ---- Inizio: ./model/SortCriteria.java ----
package gestore_libreria.model;

public enum SortCriteria {
    NONE,
    TITLE_ASC,
    TITLE_DESC,
    AUTHOR_ASC,
    AUTHOR_DESC,
    RATING_ASC,
    RATING_DESC,
}

// ---- Fine: ./model/SortCriteria.java ----


// ---- Inizio: ./model/Book.java ----
package gestore_libreria.model;

public class Book {
    //dichiaro le variabili del libro
    private int id;
    //obbligatori
    private final String title;
    private final String author;

    //facoltativi
    private final String isbn;
    private final String genre;
    private final int rating;
    private final String readingState;
    private final String coverPath;     //per le immagini di copertina

    /**
     * Costruisce un'istanza di Book utilizzando un oggetto Builder.
     *
     * @param builder Il Builder contenente i dati per costruire il libro.
     * @pre builder non deve essere null.
     * @pre builder.title non deve essere null o vuoto.
     * @pre builder.author non deve essere null o vuoto.
     * @pre builder.rating deve essere un valore tra 0 e 5 (inclusi).
     * @pre builder.readingState deve essere uno stato di lettura valido ("letto", "in lettura", "da leggere").
     * @post Viene creata una nuova istanza di Book con i valori specificati dal Builder.
     * @post Tutti i campi 'final' del libro sono inizializzati e non modificabili successivamente.
     */
    private Book(Builder builder){
        this.title = builder.title;
        this.author = builder.author;
        this.isbn = builder.isbn;
        this.genre = builder.genre;
        this.rating = builder.rating;
        this.readingState = builder.readingState;
        this.coverPath = builder.coverPath;
        this.id = builder.id;
    }

    //getter per la lettura

    public String getTitle() {
        return title;
    }

    public String getAuthor() {
        return author;
    }

    public String getIsbn() {
        return isbn;
    }

    public String getGenre() {
        return genre;
    }

    public int getRating() {
        return rating;
    }

    public String getReadingState() {
        return readingState;
    }

    public String getCoverPath() {
        return coverPath;
    }

    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID del libro. Questo metodo è generalmente usato solo dal database
     * dopo che il libro è stato salvato e gli è stato assegnato un ID.
     *
     * @param id L'ID univoco da assegnare al libro.
     * @pre id deve essere un intero
     * @post L'ID del libro è impostato al valore fornito.
     */
    public void setId(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "Book{" +
                "id='" + id + '\'' +
                ", title='" + title + '\'' +
                ", author='" + author + '\'' +
                ", isbn='" + isbn + '\'' +
                ", genre='" + genre + '\'' +
                ", rating=" + rating +
                ", readingState='" + readingState + '\'' +
                ", coverPath='" + coverPath + '\'' +
                '}';
    }

    //builder per la costruzione dell'oggetto libro
    public static class Builder{


        //obbligatori
        private final String title;
        private final String author;

        //facoltativi
        private String isbn = "";
        private String genre = "";
        private int rating = 0;
        private String readingState = "da leggere";
        private String coverPath = "";        //per le immagini di copertina
        private int id = 0;

        /**
         * Costruisce un nuovo Builder per l'oggetto Book.
         *
         * @param title Il titolo obbligatorio del libro.
         * @param author L'autore obbligatorio del libro.
         * @pre title non deve essere null o vuoto.
         * @pre author non deve essere null o vuoto.
         * @post Il Builder è inizializzato con il titolo e l'autore specificati.
         * @post I campi facoltativi sono inizializzati con i loro valori di default.
         * @throws IllegalArgumentException se il titolo o l'autore non rispettano le pre-condizioni.
         */
        public Builder(String title, String author) {
            if(title == null || title.isBlank() || author == null || author.isEmpty()){
                throw new IllegalArgumentException("Titolo e autore sono obbligatori");
            }
            this.title = title;
            this.author = author;
        }

        //restituisco un oggetto builder per ogni campo inserito
        public Builder isbn(String isbn){
            this.isbn = isbn;
            return this;
        }

        public Builder genre(String genre){
            this.genre = genre;
            return this;
        }

        public Builder rating(int rating){
            if(rating < 0 || rating > 5){
                throw new IllegalArgumentException("Valore non valido, rating compreso tra 0 e 5");
            }
            this.rating = rating;
            return this;
        }

        public Builder readingState(String state) {
            if (!state.matches("letto|in lettura|da leggere"))
                this.readingState = "da leggere";
                //throw new IllegalArgumentException("Stato non valido");
            this.readingState = state;
            return this;
        }

        public Builder coverPath(String path) {
            this.coverPath = path;
            return this;
        }

        public Builder id(int id) {
            this.id = id;
            return this;
        }

        public Book build() {
            return new Book(this);
        }
    }
}

// ---- Fine: ./model/Book.java ----


// ---- Inizio: ./observer/BookObserver.java ----
package gestore_libreria.observer;

public interface BookObserver {
    /**
     * Questo metodo viene chiamato dall'oggetto osservato per notificare gli osservatori
     * che si è verificato un cambiamento nello stato dei dati dei libri.
     *
     * @pre L'oggetto osservabile (es. ConcreteBookManager) ha subito una modifica nel suo stato
     * relativo ai libri e ha chiamato questo metodo.
     * @post L'osservatore ha ricevuto la notifica e può agire di conseguenza (aggiornare la UI in questo caso specifico).
     */
    void update();
}

// ---- Fine: ./observer/BookObserver.java ----


// ---- Inizio: ./observer/ConcreteBookObserver.java ----
package gestore_libreria.observer;

import gestore_libreria.db.BookManager;
import gestore_libreria.db.BookRepositoryImplementor;
import gestore_libreria.db.ConcreteBookManager;
import gestore_libreria.db.SQLiteBookRepository;
import gestore_libreria.model.Book;
import gestore_libreria.ui.BooksPanelUI;
import gestore_libreria.ui.GestoreLibreriaUI;

import java.util.List;

/**
 * Implementazione concreta dell'interfaccia BookObserver.
 * Questo osservatore è responsabile dell'aggiornamento dell'interfaccia utente (UI)
 * quando vengono apportate modifiche allo stato del database.
 */
public class ConcreteBookObserver implements BookObserver{

    //qui ho un'istanza del ConcreteBookManager
    private BooksPanelUI bookPanel;
    private GestoreLibreriaUI gestoreLibreriaUI;
    private ConcreteBookManager db;

    /**
     * Costruisce una nuova istanza di ConcreteBookObserver e richiama il metodo {@code update()}.
     *
     * @param gestoreLibreriaUI l'interfaccia utente principale dove vengono visualizzati i criteri di ricerca e il {@code bookPanel}
     * @param bookPanel Il pannello dell'interfaccia utente che questo osservatore deve aggiornare.
     * @param db Istanza del database utilizzato
     * @pre gestoreLibreriaUI non deve essere null
     * @pre booksPanel non deve essere null.
     * @post L'osservatore è inizializzato con un riferimento al pannello UI.
     * @throws IllegalArgumentException se booksPanelUI è null.
     */
    public ConcreteBookObserver(GestoreLibreriaUI gestoreLibreriaUI, BooksPanelUI bookPanel, ConcreteBookManager db) {
        this.bookPanel = bookPanel;
        this.db = db;
        this.gestoreLibreriaUI = gestoreLibreriaUI;
        this.db.attach(this);
        update();
    }

    /**
     * Aggiorna la vista dell'interfaccia utente recuperando tutti i libri dal database
     * e visualizzandoli, quindi aggiorna lo stato dei menu Undo/Redo.
     * Questo metodo viene invocato quando l'oggetto osservabile (es. BookManager)
     * notifica un cambiamento.
     *
     * @pre Il manager dei libri (db) e il pannello dei libri (bookPanel) devono essere stati inizializzati correttamente.
     * @post La lista completa dei libri è stata recuperata dal database.
     * @post Il metodo displayBooks del bookPanel è stato invocato con la lista aggiornata dei libri,
     * causando il refresh dell'interfaccia utente.
     * @post Lo stato dei menu Undo/Redo è stato aggiornato per riflettere la disponibilità di operazioni.
     */
    @Override
    public void update() {
        System.out.println("Aggiorno la bookView");
        List<Book> books = db.getAllBook(gestoreLibreriaUI.getCurrentSortCriteria());
        bookPanel.displayBooks(books);
        gestoreLibreriaUI.updateUndoRedoMenuState();
    }

    /**
     * Rimuove questo osservatore dalla lista degli osservatori dell'oggetto osservabile (db). Attualmente eseguito
     * alla chiusura del programma
     *
     * @pre L'oggetto osservabile (db) non deve essere null.
     * @pre Questo osservatore deve essere precedentemente stato "sottoscritto" (attached) al db.
     * @post Se db non è null, questo osservatore è stato rimosso dalla sua lista di osservatori.
     * @post L'osservatore non riceverà più notifiche da db.
     */
    public void unsubscribe() {
        if(this.db != null) {
            this.db.detach(this);
            System.out.println("Unsubscribed");
        }
    }
}

// ---- Fine: ./observer/ConcreteBookObserver.java ----


// ---- Inizio: ./observer/Subject.java ----
package gestore_libreria.observer;

import java.util.List;
import java.util.Observer;
import java.util.concurrent.CopyOnWriteArrayList;

public abstract class Subject {
    private List<BookObserver> observers;

    public Subject() {
        observers = new CopyOnWriteArrayList<>();
    }

    /**
     * Ci permette di iscrivere il nostro ConcreteSubject alla lista degli observers per
     * essere notificato
     *
     * @param observer contiene la logica {@code update()} e {@code unsubscribe()}, è l'elemento che verrà inserito nella lista
     * @pre {@code observer} non deve essere null
     * @pre {@code observer} non deve essere contenuto nella lista
     * @post l'observer è stato correttamente inserito nella lista
     */
    public void attach(BookObserver observer) {
        if(!observers.contains(observer)) {
            observers.add(observer);
        }
    }

    /**
     * Ci permette di disiscrivere il nostro ConcreteSubject dalla lista degli observer
     * @param observer ccontiene la logica {@code update()} e {@code unsubscribe()}, è l'elemento che verrà inserito
     * nella lista
     * @pre {@code observer} non deve essere null
     * @pre {@code observer} deve essere contenuto nella lista
     * @post l'observer è stato correttamente rimosso dalla lista degli observer
     * @post l'observer non verrà più notificato
     */
    public void detach(BookObserver observer) {
        if(observers.contains(observer)) {
            observers.remove(observer);
        }
    }

    /**
     * Notifica tutti gli observer iscritti invocando il loro metodo {@code update()}
     * @post tutti gli observer contenuti nella lista sono stati notificati
     */
    public void notifyObservers() {
        for (BookObserver observer : observers) {
            observer.update();
        }
    }
}

// ---- Fine: ./observer/Subject.java ----


// ---- Inizio: ./memento/BookHistoryManager.java ----
package gestore_libreria.memento;

import gestore_libreria.model.Book;

import java.util.Stack;

/**
 * Gestisce la cronologia degli stati di un oggetto {@link Book} attraverso il pattern memento.
 * Permette le operazioni di undo/redo notificando gli observer registrati
 */

public class BookHistoryManager {

    private final Stack<BookMemento> undoStack = new Stack<>();
    private final Stack<BookMemento> redoStack = new Stack<>();

    private OnMementoListener restoreListener;

    /**
     * Indicano le possibili direzioni dell'operazione di ripristino: UNDO e REDO
     */
    public enum ActionDirection{
        UNDO, REDO;
    }

    /**
     * Interfaccia per gestire il restore di un {@link BookMemento}.
     * Deve essere implementata da chi ha la possibilità di modificare lo stato del database: {@link gestore_libreria.db.BookManager}
     * nel nostro caso.
     */
    public interface OnMementoListener {
        /**
         * Viene richiamato quando si desidera ripristinare uno stato precedente.
         *
         * @param memento rappresenta lo stato da ripristinare
         * @param direction direzione dell'operazione UNDO/REDO
         * @pre {@code memento} non deve essere null
         * @pre {@code direction} non deve essere null
         * @post lo stato viene ripristinato secondo la direzione indicata
         */
        void restore(BookMemento memento, ActionDirection direction);
    }

    /**
     * Salva un nuovo stato e svuota lo stack redo
     *
     * @param memento lo stato corrente da salvare
     * @pre {@code memento} non deve essere null
     * @post memento si posziona in cima allo stack undo
     * @post lo stack redo viene svuotato
     */
    public void save(BookMemento memento) {
        undoStack.push(memento);
        redoStack.clear();      // una volta che faccio una nuova operazione ripulisco lo stack redo
    }

    /**
     * Imposta un listner per le notifiche di ripristino
     *
     * @param listener listener da notificare
     * @post il listener è stato aggiornato
     */
    public void setOnMementoRestoreListener(OnMementoListener listener) {
        this.restoreListener = listener;
    }

    /**
     * Esegue l'operazione di undo
     * @return il memento ripristinato o {@code null} se non disponibile
     * @pre lo stack undo può essere vuoto ma restituisce null
     * @post se disponibile il memento viene rimosso dallo stack undo e spostato nello stack redo.
     * @post se presente un listener, viene notificato con {@code ActionDirection.UNDO}
     */
    public BookMemento undo() {
        if (!undoStack.isEmpty()) {
            BookMemento memento = undoStack.pop();
            redoStack.push(memento);        //prendo il memento dalla pila undo e lo sposto nella pila redo
            if (restoreListener != null) {
                restoreListener.restore(memento, ActionDirection.UNDO);
            }
            return memento;
        }
        return null;
    }

    /**
     * Esegue l'operazione di redo
     * @return il memento ripristinato o {@code null} se non disponibile
     * @pre lo stack redo può essere vuoto ma restituisce null
     * @post se disponibile il memento viene rimosso dallo stack redo e spostato nello stack undo.
     * @post se presente un listener, viene notificato con {@code ActionDirection.REDO}
     */
    public BookMemento redo() {
        if (!redoStack.isEmpty()) {
            BookMemento memento = redoStack.pop();
            undoStack.push(memento);
            if (restoreListener != null) {
                restoreListener.restore(memento, ActionDirection.REDO);
            }
            return memento;
        }
        return null;
    }

    //metodi accessori

    /**
     * Verifica se è possibile effettuare un'operazione di undo.
     *
     * @return {@code true} se lo stack undo non è vuoto
     * @post il risultato riflette lo stato dello stack undo
     */
    public boolean canUndo() {
        return !undoStack.isEmpty();
    }

    /**
     * Verifica se è possibile effettuare un'operazione di redo.
     *
     * @return {@code true} se lo stack redo non è vuoto
     * @post il risultato riflette lo stato dello stack redo
     */
    public boolean canRedo() {
        return !redoStack.isEmpty();
    }

    /**
     * Pulisce completamente la cronologia di undo e redo.
     *
     * @post entrambi gli stack sono vuoti
     */
    public void cleanAll(){
        undoStack.clear();
        redoStack.clear();
    }


}

// ---- Fine: ./memento/BookHistoryManager.java ----


// ---- Inizio: ./memento/BookMemento.java ----
package gestore_libreria.memento;

import gestore_libreria.model.Book;

/**
 * Rappresenta un memento contenente lo stato di un oggetto {@link Book}
 * e il tipo di operazione eseguita (ADD, REMOVE e UPDATE)
 */

public class BookMemento {

    /**
     * definiamo i tipi principali di operazioni che possiamo eseguire
     */

    public enum OperationType {
        ADD, REMOVE, UPDATE;
    }

    private final Book bookState;       // lo stato dopo l'operazione
    private final OperationType operationType;      //il tipo di operazione
    private final Book previousBookState;       // lo stato del libro prima dell'operazione

    // costruttore

    /**
     * Costruttore per operazioni di tipo ADD o REMOVE.
     *
     * @param bookState stato del libro dopo l'operazione
     * @param operationType tipo di operazione (solo ADD o REMOVE)
     * @pre {@code bookState} non deve essere null
     * @pre {@code operationType == ADD || operationType == REMOVE}
     * @pre {@code operationType != UPDATE}
     * @post il memento rappresenta l'operazione passata con stato precedente nullo
     * @throws IllegalArgumentException se {@code operationType == UPDATE}
     */
    public BookMemento(Book bookState, OperationType operationType) {
        //costruttore per le operazioni di delete e add, NO UPDATE
        if(operationType == OperationType.UPDATE){
            throw new IllegalArgumentException("Update operation not supported");
        }
        this.bookState = bookState;
        this.operationType = operationType;
        this.previousBookState = null;
    }

    /**
     * Costruttore per operazioni di tipo UPDATE.
     *
     * @param bookState stato del libro dopo l'operazione
     * @param operationType deve essere {@code UPDATE}
     * @param previousBookState stato del libro prima dell'update
     * @pre {@code bookState} non deve essere null
     * @pre {@code previousBookState} non deve essere null
     * @pre {@code operationType == UPDATE}
     * @pre {@code operationType != ADD || operationType != REMOVE}
     * @post il memento rappresenta correttamente l'update con stato precedente e successivo
     * @throws IllegalArgumentException se {@code operationType == ADD || operationType == REMOVE}
     */
    public BookMemento(Book bookState, OperationType operationType, Book previousBookState) {
        //costruttore per l'operazione di UPDATE
        if(operationType == OperationType.ADD || operationType == OperationType.REMOVE){
            throw new IllegalArgumentException("Add operation and Remove operation not supported");
        }
        this.bookState = bookState;
        this.previousBookState = previousBookState;
        this.operationType = operationType;
    }

    public Book getBookState() {
        return bookState;
    }

    public OperationType getOperationType() {
        return operationType;
    }

    public Book getPreviousBookState() {
        return previousBookState;
    }

    @Override
    public String toString() {
        return "BookMemento{" +
                "bookState=" + bookState +
                ", operationType=" + operationType +
                ", previousBookState=" + previousBookState +
                '}';
    }
}

// ---- Fine: ./memento/BookMemento.java ----


// ---- Inizio: ./ui/BooksPanelUI.java ----
package gestore_libreria.ui;

import gestore_libreria.model.Book;

import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import java.util.function.Consumer;


public class BooksPanelUI extends JPanel {
    private JPanel bookListPanel;
    private Consumer<Book> onBookClickListener;     //click per i dettagli del libro
    private Consumer<Book> onDeleteBookListener;    //click destro per eliminare un libro
    // Colori per lo stato di lettura
    private static final Color READING_STATE_COLOR = new Color(252, 202, 70);
    private static final Color UNREAD_STATE_COLOR = new Color(90, 93, 95);
    private static final Color READ_STATE_COLOR = new Color(112, 224, 0);

    private GestoreLibreriaUI gestoreLibreriaUI;

    private JPopupMenu popupMenu;

    public BooksPanelUI(GestoreLibreriaUI gestoreLibreriaUI) {
        setLayout(new BorderLayout());
        //setBorder(BorderFactory.createTitledBorder("Lista Libri"));

        this.gestoreLibreriaUI = gestoreLibreriaUI;

        bookListPanel = new JPanel();
        bookListPanel.setLayout(new BoxLayout(bookListPanel, BoxLayout.Y_AXIS));

        JScrollPane scrollPane = new JScrollPane(bookListPanel);
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);

        add(scrollPane, BorderLayout.CENTER);

        inizializzaPopupMenu();
    }

    public void setOnDeleteBookListener(Consumer<Book> onDeleteBookListener) {
        this.onDeleteBookListener = onDeleteBookListener;
    }

    public void setOnBookClickListener(Consumer<Book> onBookClickListener) {
        this.onBookClickListener = onBookClickListener;
    }

    private void inizializzaPopupMenu() {
        popupMenu = new JPopupMenu();
        JMenuItem deleteItem = new JMenuItem("Elimina");
        deleteItem.setForeground(Color.RED);
        deleteItem.addActionListener(e -> {});      //TODO
        popupMenu.add(deleteItem);
    }

    private void showPopupMenu(MouseEvent e, Book book) {
        if (e.isPopupTrigger()) { // isPopupTrigger() verifica se è un evento di click destro (o equivalente su altri OS)
            // Collega l'azione "Elimina" al libro specifico
            // Rimuovi eventuali listener precedenti per evitare duplicati se il popup è riusato
            for (int i = 0; i < popupMenu.getComponentCount(); i++) {
                Component comp = popupMenu.getComponent(i);
                if (comp instanceof JMenuItem menuItem) {
                    if (menuItem.getText().equals("Elimina")) {
                        // Rimuove tutti gli ActionListener esistenti per "Elimina"
                        for (java.awt.event.ActionListener al : menuItem.getActionListeners()) {
                            menuItem.removeActionListener(al);
                        }
                        // Aggiunge il listener per l'eliminazione specifica di questo libro
                        menuItem.addActionListener(actionEvent -> {
                            if (onDeleteBookListener != null) {
                                onDeleteBookListener.accept(book); // Notifica il listener esterno con il libro da eliminare
                            }
                        });
                        break; // Trovato e configurato l'elemento "Elimina"
                    }
                }
            }
            popupMenu.show(e.getComponent(), e.getX(), e.getY());
        }
    }


    //metodo che verrà richiamato per aggiornare la lista dei libri con l'observer
    public void displayBooks(List<Book> books) {
        bookListPanel.removeAll();
        if (books.isEmpty()) {
            JPanel emptyPanel = new JPanel(new GridBagLayout());
            emptyPanel.setOpaque(false); // Trasparente per mantenere lo sfondo

            JLabel emptyLabel = new JLabel();

            // Carica l'immagine per la libreria vuota
            ImageIcon emptyIcon = GestoreLibreriaUI.loadAndScaleImage("/images/empty_library.png", 200, 200);

            if (emptyIcon != null) {
                emptyLabel.setIcon(emptyIcon);
            } else {
                // Fallback al testo se l'immagine non è disponibile
                emptyLabel.setText("Nessun libro presente nella libreria.");
                emptyLabel.setForeground(Color.WHITE);
                emptyLabel.setHorizontalAlignment(SwingConstants.CENTER);
            }

            // Centra l'etichetta nel pannello
            GridBagConstraints gbc = new GridBagConstraints();
            gbc.gridx = 0;
            gbc.gridy = 0;
            gbc.anchor = GridBagConstraints.CENTER;

            emptyPanel.add(emptyLabel, gbc);
            bookListPanel.add(emptyPanel);
        } else {
            for (Book book : books) {
                JPanel bookPanel = new JPanel(new BorderLayout());

                int coverHeight = 100;
                int verticalPadding = 16;
                bookPanel.setPreferredSize(new Dimension(400, coverHeight + verticalPadding));
                bookPanel.setMaximumSize(new Dimension(Short.MAX_VALUE, coverHeight + verticalPadding));
                bookPanel.setMinimumSize(new Dimension(400, coverHeight + verticalPadding));

                bookPanel.setBorder(BorderFactory.createEmptyBorder(10, 5, 5, 5));
                bookPanel.setForeground(Color.WHITE); // Colore del testo per i pannelli dei libri

                //Mouse Listener
                bookPanel.addMouseListener(new MouseAdapter() {
                    @Override
                    public void mouseClicked(MouseEvent e) {
                        if(SwingUtilities.isLeftMouseButton(e)) {
                            if (onBookClickListener != null) {
                                onBookClickListener.accept(book); // Notifica il listener con il libro cliccato
                            }
                        }

                    }

                    // Effetti visivi al passaggio del mouse
                    @Override
                    public void mouseEntered(MouseEvent e) {
                        bookPanel.setBackground(new Color(78, 78, 78)); // Colore più chiaro al passaggio
                        bookPanel.setCursor(new Cursor(Cursor.HAND_CURSOR)); // Cursore a mano
                    }

                    @Override
                    public void mouseExited(MouseEvent e) {
                        bookPanel.setBackground(new Color(30,30,30)); // Torna al colore originale
                        bookPanel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR)); // Cursore normale
                    }

                    @Override
                    public void mousePressed(MouseEvent e) {
                        showPopupMenu(e, book);
                    }

                    @Override
                    public void mouseReleased(MouseEvent e) {
                        showPopupMenu(e, book);
                    }
                });



                // Copertina
                JLabel coverLabel = new JLabel();
                coverLabel.setPreferredSize(new Dimension(70, 100));
                coverLabel.setOpaque(true);
                coverLabel.setBackground(Color.LIGHT_GRAY); // Colore di sfondo per l'area della copertina

                //caricamento immagine
                ImageIcon coverIcon = GestoreLibreriaUI.loadAndScaleImage(book.getCoverPath(), 70, 100);

                if (coverIcon != null) {
                    coverLabel.setIcon(coverIcon);
                    coverLabel.setBackground(null); // Rimuovi il background grigio se c'è un'immagine valida
                } else {
                    // Prova a caricare un'immagine placeholder
                    ImageIcon placeholder = GestoreLibreriaUI.loadPlaceholderImage(70, 100);
                    if (placeholder != null) {
                        coverLabel.setIcon(placeholder);
                    } else {
                        // Se non riesce a caricare nemmeno il placeholder, mostra testo
                        coverLabel.setText("Err Img");
                        coverLabel.setHorizontalAlignment(SwingConstants.CENTER);
                        coverLabel.setForeground(Color.RED);
                        coverLabel.setBackground(Color.DARK_GRAY);
                    }
                }
                bookPanel.add(coverLabel, BorderLayout.WEST);
                buildSingleElement(book, bookPanel);

                // spacing
                bookListPanel.add(bookPanel);
                //bookListPanel.add(Box.createRigidArea(new Dimension(0, 6)));

            }
        }
        bookListPanel.revalidate();
        bookListPanel.repaint();
    }

    private void buildSingleElement(Book book, JPanel row) {
        // container verticale
        JPanel center = new JPanel();
        center.setOpaque(false);
        center.setLayout(new BoxLayout(center, BoxLayout.Y_AXIS));
        center.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 8));
        center.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Riga 1
        JPanel line1 = new JPanel(new BorderLayout());
        line1.setOpaque(false);
        line1.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel titleLabel = new JLabel(book.getTitle());
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD));
        line1.add(titleLabel, BorderLayout.WEST);

        JPanel stars = new JPanel(new FlowLayout(FlowLayout.RIGHT, 2, 0));
        stars.setOpaque(false);
        for (int i = 0; i < 5; i++) {
            JLabel star = new JLabel("★");
            star.setForeground(i < book.getRating()
                    ? new Color(255, 215, 0)
                    : Color.DARK_GRAY);
            stars.add(star);
        }
        line1.add(stars, BorderLayout.EAST);

        center.add(line1);

        // Riga 2
        JPanel line2 = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        line2.setOpaque(false);
        line2.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel authorLabel = new JLabel(book.getAuthor());
        authorLabel.setForeground(Color.LIGHT_GRAY);
        line2.add(authorLabel);

        center.add(line2);

        // Riga 3
        JPanel line3 = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 6));
        line3.setOpaque(false);
        line3.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel stateLabel = new JLabel(book.getReadingState().toUpperCase());
        stateLabel.setOpaque(true);
        stateLabel.setBorder(BorderFactory.createEmptyBorder(0, 8, 4, 8));
        stateLabel.setForeground(new Color(30,30,30));
        switch (book.getReadingState().toUpperCase()) {
            case "IN LETTURA" -> stateLabel.setBackground(READING_STATE_COLOR);
            case "DA LEGGERE" -> stateLabel.setBackground(UNREAD_STATE_COLOR);
            case "LETTO" -> stateLabel.setBackground(READ_STATE_COLOR);
            default -> stateLabel.setBackground(Color.GRAY);
        }
        line3.add(stateLabel);

        center.add(line3);

        // aggiungo center al row
        row.add(center, BorderLayout.CENTER);


    }
}

// ---- Fine: ./ui/BooksPanelUI.java ----


// ---- Inizio: ./ui/GestoreLibreriaUI.java ----
package gestore_libreria.ui;

import javax.swing.*;
import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.formdev.flatlaf.themes.*;
import gestore_libreria.db.*;
import gestore_libreria.model.Book;
import gestore_libreria.model.SortCriteria;
import gestore_libreria.observer.ConcreteBookObserver;

/**
 * Classe principale dell'interfaccia grafica per la gestione della libreria.
 * Estende {@link JFrame}.
 * Integra e concretizza le operazioni possibili con la libreria, visualizzazione, modifica, aggiunta, rimozione e gestione
 * dello stato dei libri.
 * Include anche undo/redo e import/export del database
 */

public class GestoreLibreriaUI extends JFrame{

    private ConcreteBookManager db;
    private ConcreteBookObserver bookObserver;
    private BooksPanelUI booksPanelUI;

    private JMenuItem undo;
    private JMenuItem redo;

    private SortCriteria currentSortCriteria = SortCriteria.NONE; // Default

    /**
     * Costruttore
     *
     * @param db Istanza di {@link ConcreteBookManager} per la gestione dei dati dei libri
     * @pre {@code db} deve essere instanziato correttamente
     * @post l'interfaccia utente viene visualizzata
     */
    public GestoreLibreriaUI(ConcreteBookManager db){
        super("Gestore Libreria");
        this.db = db;
        inizializzaUI();
    }

    /**
     * Inzializza l'interfaccia utente, configurando layout, meno pannelli e listener
     */
    private void inizializzaUI() {
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        setSize(1080, 720);
        setLocationRelativeTo(null);
        setLayout(new BorderLayout());

        JFrame.setDefaultLookAndFeelDecorated(true);
        JDialog.setDefaultLookAndFeelDecorated(true);

        setJMenuBar(creaMenuBar());

        JPanel mainPanel = new JPanel(new BorderLayout());
        setContentPane(mainPanel);

        //sezione sx
        JPanel leftPanel = inizializzaSezioneSX();

        JPanel rightPanel = inizializzaSezioneDX();

        mainPanel.add(leftPanel, BorderLayout.WEST);
        mainPanel.add(rightPanel, BorderLayout.CENTER);

        this.booksPanelUI = new BooksPanelUI(this);
        rightPanel.add(booksPanelUI, BorderLayout.CENTER);

        booksPanelUI.setOnBookClickListener(this::showBookDetails);
        booksPanelUI.setOnDeleteBookListener(this::PopupMenuAction);

        this.bookObserver = new ConcreteBookObserver(this,this.booksPanelUI,this.db);

        updateUndoRedoMenuState();

        setVisible(true);

        // Discrivo l'observer nel caso in cui decidiamo di chiudere la finestra
        addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                if (bookObserver != null) {
                    bookObserver.unsubscribe();
                }
            }
        });

    }

    /**
     * Mostra i dettagli di un libro selezionato, permette la modifica e l'eliminazione di un oggetto {@link Book}
     * @pre {@code book} non deve essere null.
     * @post Se modificato, il libro viene aggiornato nel database e l'interfaccia viene aggiornata.
     * @post Se eliminato, il libro viene rimosso dal database e l'interfaccia viene aggiornata.
     * @param book
     */
    private void showBookDetails(Book book) {
        JTextField titoloField = new JTextField(book.getTitle(), 20);
        JTextField autoreField = new JTextField(book.getAuthor(), 20);
        JTextField isbnField = new JTextField(book.getIsbn() != null ? book.getIsbn() : "", 20);
        JTextField genreField = new JTextField(book.getGenre() != null ? book.getGenre() : "", 20);
        JSpinner ratingSpinner = new JSpinner(new SpinnerNumberModel(book.getRating(), 1, 5, 1));
        String[] statiLettura = {"DA LEGGERE", "IN LETTURA", "LETTO"};
        JComboBox<String> statoCombo = new JComboBox<>(statiLettura);
        statoCombo.setSelectedItem(book.getReadingState() != null ? book.getReadingState() : "DA LEGGERE");

        JTextField imagePathField = new JTextField(book.getCoverPath() != null ? book.getCoverPath() : "", 15);
        imagePathField.setEditable(false);
        JButton browseBtn = new JButton("Sfoglia");
        browseBtn.setEnabled(false);

        JLabel imagePreview = new JLabel();
        int width = 120;
        int height = 180;
        imagePreview.setPreferredSize(new Dimension(width, height));

        ImageIcon selectedIcon = loadAndScaleImage(book.getCoverPath(), width, height);
        if (selectedIcon != null) {
            imagePreview.setIcon(selectedIcon);
        } else {
            ImageIcon placeholder = loadPlaceholderImage(width, height);
            if (placeholder != null) {
                imagePreview.setIcon(placeholder);
            }else {
                imagePreview.setText("Immagine non disponibile");
            }
        }

        JPanel imageWrapper = new JPanel();
        imageWrapper.setLayout(new BorderLayout());
        imageWrapper.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 20));
        imageWrapper.add(imagePreview, BorderLayout.CENTER);

        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.add(new JLabel("Titolo:"));
        panel.add(titoloField);
        panel.add(new JLabel("Autore:"));
        panel.add(autoreField);
        panel.add(new JLabel("Genere:"));
        panel.add(genreField);
        panel.add(new JLabel("ISBN:"));
        panel.add(isbnField);
        panel.add(new JLabel("Rating (1-5):"));
        panel.add(ratingSpinner);
        panel.add(new JLabel("Stato lettura:"));
        panel.add(statoCombo);
        panel.add(new JLabel("Copertina:"));
        JPanel filePanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        filePanel.add(imagePathField);
        filePanel.add(browseBtn);
        panel.add(filePanel);

        JPanel BookPanel = new JPanel(new BorderLayout());
        BookPanel.add(panel, BorderLayout.CENTER);
        BookPanel.add(imageWrapper, BorderLayout.NORTH);
        imageWrapper.setLayout(new FlowLayout(FlowLayout.CENTER));

        // Disabilita tutti i campi per la sola visualizzazione
        setFieldsEditable(false, titoloField, autoreField, isbnField, genreField, ratingSpinner, statoCombo, browseBtn, imagePathField);

        String[] options = {"Modifica", "<html><font color='red'>Elimina</font></html>", "Chiudi"};
        int choice = JOptionPane.showOptionDialog(this, BookPanel, "Dettagli Libro",
                JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE,
                null, options, options[2]);
        if (choice == 0) {
            setFieldsEditable(true, titoloField, autoreField, isbnField, genreField, ratingSpinner, statoCombo, browseBtn, imagePathField);
            browseButtonAction(browseBtn, imagePathField, imagePreview, width, height);

            int result = JOptionPane.showConfirmDialog(this, BookPanel, "Modifica Libro", JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);
            if (result == JOptionPane.OK_OPTION) {
                String newTitolo = titoloField.getText().trim();
                String newAutore = autoreField.getText().trim();
                String newIsbn = isbnField.getText().trim();
                String newGenre = genreField.getText().trim();
                int newRating = (Integer) ratingSpinner.getValue();
                String newStato = (String) statoCombo.getSelectedItem();
                String newPath = imagePathField.getText().trim();

                if (!newTitolo.isEmpty() && !newAutore.isEmpty()) {
                    Book updatedBook = new Book.Builder(newTitolo, newAutore)
                            .id(book.getId())
                            .isbn(newIsbn)
                            .rating(newRating)
                            .readingState(newStato)
                            .coverPath(newPath)
                            .genre(newGenre)
                            .build();

                    db.updateBook(book, updatedBook); // Passo sia il vecchio che il nuovo libro per l'undo/redo
                    JOptionPane.showMessageDialog(this, "Libro modificato con successo!", "Successo", JOptionPane.INFORMATION_MESSAGE);
                } else {
                    JOptionPane.showMessageDialog(this, "Titolo e autore sono obbligatori.", "Errore", JOptionPane.ERROR_MESSAGE);
                }
            }
            setFieldsEditable(false, titoloField, autoreField, isbnField, genreField, ratingSpinner, statoCombo, browseBtn, imagePathField);
        } else if (choice == 1) {
            int confirm = JOptionPane.showConfirmDialog(this,
                    "Sei sicuro di voler eliminare il libro '" + book.getTitle() + "'?",
                    "Conferma Eliminazione", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
            if (confirm == JOptionPane.YES_OPTION) {
                db.deleteBook(book);
                JOptionPane.showMessageDialog(this, "Libro eliminato con successo!", "Successo", JOptionPane.INFORMATION_MESSAGE);
            }
        }
    }

    /**
     * Utilizzato in {@code showBookDetails()} imposta la modificabilità dei campi dei dettagli del libro.
     *
     * @param editable True per rendere i campi modificabili, false per renderli non modificabili.
     * @param titoloField Campo del titolo.
     * @param autoreField Campo dell'autore.
     * @param isbnField Campo dell'ISBN.
     * @param genreField Campo del genere.
     * @param ratingSpinner Spinner del rating.
     * @param statoCombo ComboBox dello stato di lettura.
     * @param browseBtn Pulsante per la selezione dell'immagine.
     * @param imagePathField Campo del percorso dell'immagine.
     * @pre Tutti i parametri devono essere inizializzati.
     * @post I campi sono impostati come modificabili o non modificabili in base al parametro {@code editable}.
     */
    private void setFieldsEditable(boolean editable, JTextField titoloField, JTextField autoreField, JTextField isbnField, JTextField genreField, JSpinner ratingSpinner,
                                   JComboBox<String> statoCombo, JButton browseBtn, JTextField imagePathField) {
        titoloField.setEditable(editable);
        autoreField.setEditable(editable);
        isbnField.setEditable(editable);
        genreField.setEditable(editable);
        ratingSpinner.setEnabled(editable);
        statoCombo.setEnabled(editable);
        browseBtn.setEnabled(editable);
        browseBtn.setVisible(editable);
        if(!editable){
            imagePathField.setColumns(20);
        }else{
            imagePathField.setColumns(15);
        }
    }

    /**
     * Gestisce l'azione di eliminazione di un libro tramite un menu contestuale.
     *
     * @param book Il libro da eliminare.
     * @pre {@code book} non deve essere null.
     * @post Se confermato, il libro viene rimosso dal database e l'interfaccia viene aggiornata.
     */
    private void PopupMenuAction(Book book) {
        int confirm = JOptionPane.showConfirmDialog(this,
                "Sei sicuro di voler eliminare il libro '" + book.getTitle() + "'?",
                "Conferma Eliminazione",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.WARNING_MESSAGE);

        if (confirm == JOptionPane.YES_OPTION) {
            db.deleteBook(book);
            JOptionPane.showMessageDialog(this,
                    "Libro eliminato con successo!",
                    "Successo",
                    JOptionPane.INFORMATION_MESSAGE);
        }
    }

    /**
     * Crea la barra dei menu dell'applicazione, includendo le voci per file e modifica.
     *
     * @return La barra dei menu configurata.
     * @post La barra dei menu contiene le voci per esportare/importare il database, uscire, e le operazioni di undo/redo.
     */
    private JMenuBar creaMenuBar() {
        JMenuBar menuBar = new JMenuBar();
        JMenu fileMenu = new JMenu("File");
        JMenu editMenu = new JMenu("Edit");
        JMenu viewMenu = new JMenu("View");

        //sezione file

        JMenuItem exportDB = new JMenuItem("Esporta Database");
        exportDB.addActionListener(e -> esportaDatabase());

        JMenuItem importDB = new JMenuItem("Importa Database");
        importDB.addActionListener(e -> importaDatabase());

        JMenuItem exit = new JMenuItem("Exit");
        exit.addActionListener(e -> {
            DatabaseConnectionSingleton.closeConnection();
            System.exit(0);

        });

        //sezione edit
        undo = new JMenuItem("⮨Undo");
        undo.addActionListener(e -> {
            db.getHistoryManager().undo();
        });

        redo = new JMenuItem("➥Redo");
        redo.addActionListener(e -> {
            db.getHistoryManager().redo();
        });

        //sezione view
        JMenuItem sortByTitleAsc = new JMenuItem("Ordina per Titolo (A-Z)");
        sortByTitleAsc.addActionListener(e -> {
            this.currentSortCriteria = SortCriteria.TITLE_ASC;
            refreshBookListView();
        });
        viewMenu.add(sortByTitleAsc);

        JMenuItem sortByTitleDesc = new JMenuItem("Ordina per Titolo (Z-A)");
        sortByTitleDesc.addActionListener(e -> {
            this.currentSortCriteria = SortCriteria.TITLE_DESC;
            refreshBookListView();
        });
        viewMenu.add(sortByTitleDesc);

        JMenuItem sortByAuthorAsc = new JMenuItem("Ordina per Autore (A-Z)");
        sortByAuthorAsc.addActionListener(e -> {
            this.currentSortCriteria = SortCriteria.AUTHOR_ASC;
            refreshBookListView();
        });
        viewMenu.add(sortByAuthorAsc);

        JMenuItem sortByAuthorDesc = new JMenuItem("Ordina per Autore (Z-A)");
        sortByAuthorAsc.addActionListener(e -> {
            this.currentSortCriteria = SortCriteria.AUTHOR_DESC;
            refreshBookListView();
        });
        viewMenu.add(sortByAuthorDesc);

        JMenuItem sortByRatingAsc = new JMenuItem("⮬Ordina per Rating (Crescente)");
        sortByRatingAsc.addActionListener(e -> {
            this.currentSortCriteria = SortCriteria.RATING_ASC;
            refreshBookListView();
        });
        viewMenu.add(sortByRatingAsc);

        JMenuItem sortByRatingDesc = new JMenuItem("⮮Ordina per Rating (Decrescente)");
        sortByRatingDesc.addActionListener(e -> {
            this.currentSortCriteria = SortCriteria.RATING_DESC;
            refreshBookListView();
        });
        viewMenu.add(sortByRatingDesc);



        fileMenu.add(exportDB);
        fileMenu.add(importDB);
        fileMenu.addSeparator();
        fileMenu.add(exit);

        editMenu.add(undo);
        editMenu.add(redo);

        menuBar.add(fileMenu);
        menuBar.add(editMenu);
        menuBar.add(viewMenu);
        return menuBar;
    }

    public SortCriteria getCurrentSortCriteria() {
        return currentSortCriteria;
    }

    private void refreshBookListView(){
        if (db != null){
            db.notifyObservers();
        }
    }

    /**
     * Aggiorna lo stato abilitato/disabilitato delle voci di menu undo e redo in base alla possibilità di eseguire tali operazioni.
     *
     * @post Le voci di menu undo e redo sono abilitate solo se le rispettive operazioni sono disponibili.
     */
    public void updateUndoRedoMenuState() {
        if (db != null && db.getHistoryManager() != null) {
            undo.setEnabled(db.getHistoryManager().canUndo());
            redo.setEnabled(db.getHistoryManager().canRedo());
        }
    }

    private void esportaDatabase() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Esporta Database");
        fileChooser.setSelectedFile(new File("books_backup.db"));

        int userSelection = fileChooser.showOpenDialog(this);

        if(userSelection == JFileChooser.APPROVE_OPTION){
            File selectedFile = fileChooser.getSelectedFile();
            try{
                DatabaseConnectionSingleton.closeConnection();
                Files.copy(new File("Books_db.db").toPath(), selectedFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
                JOptionPane.showMessageDialog(this, "Database esportato con successo.");
            } catch (IOException e) {
                JOptionPane.showMessageDialog(this, "Errore nell'esportazione del database.");
            }finally {
                try {
                    DatabaseConnectionSingleton.getInstance();
                } catch (SQLException e) {
                    throw new RuntimeException(e);
                }
                booksPanelUI.displayBooks(db.getAllBook(this.currentSortCriteria));
            }
        }
    }

    private void importaDatabase(){
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Importa Database");
        fileChooser.setFileFilter(new javax.swing.filechooser.FileNameExtensionFilter("SQLite Database Files (*.db)", "db"));

        int userSelection = fileChooser.showOpenDialog(this);

        if(userSelection == JFileChooser.APPROVE_OPTION){
            File selectedFile = fileChooser.getSelectedFile();

            int confirm = JOptionPane.showConfirmDialog(this, "L'importazione sovrascriverà il database esistente, sei sicuro di voler continuare?","Conferma Importazione", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);

            if(confirm == JOptionPane.YES_OPTION){
                try{
                    DatabaseConnectionSingleton.closeConnection();
                    Files.copy(selectedFile.toPath(), new File("Books_db.db").toPath(), StandardCopyOption.REPLACE_EXISTING);
                    JOptionPane.showMessageDialog(this, "Database importato con successo.");

                    DatabaseConnectionSingleton.getInstance();

                    db = new ConcreteBookManager(new SQLiteBookRepository());
                    bookObserver.unsubscribe();
                    bookObserver = new ConcreteBookObserver(this,this.booksPanelUI,this.db);

                    booksPanelUI.displayBooks(db.getAllBook(this.currentSortCriteria));
                }catch (IOException | SQLException e){
                    JOptionPane.showMessageDialog(this, "Errore durante l'importazione del database: " + e.getMessage(), "Errore Importazione", JOptionPane.ERROR_MESSAGE);
                }
            }

        }
    }

    private JPanel inizializzaSezioneDX(){
        JPanel rightPanel = new JPanel(new BorderLayout());

        JPanel searchBarPanel = new JPanel(new BorderLayout());
        // Barra di ricerca con FlatLaf arrotondata
        JTextField searchField = new JTextField("Search");
        searchField.putClientProperty("JTextField.roundRect", true);
        searchField.setBackground(new Color(53, 53, 53));
        searchField.setForeground(Color.WHITE);
        searchField.setCaretColor(Color.WHITE);
        searchField.setPreferredSize(new Dimension(120, 30));
        searchField.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));

        String[] searchCriteria = {"Titolo", "Autore"};
        JComboBox<String> searchCriteriaCombo = new JComboBox<>(searchCriteria);
        searchCriteriaCombo.setPreferredSize(new Dimension(100, 30));
        searchCriteriaCombo.putClientProperty("JComboBox.is=roundReact",true);
        searchCriteriaCombo.setBackground(new Color(53, 53, 53));
        searchCriteriaCombo.setForeground(Color.WHITE);

        searchBarPanel.add(searchField, BorderLayout.CENTER);
        searchBarPanel.add(searchCriteriaCombo, BorderLayout.EAST);

        rightPanel.add(searchBarPanel, BorderLayout.NORTH);

        // Listener per la ricerca
        searchField.addActionListener(e -> {
            String searchText = searchField.getText().trim();
            String criterion = searchCriteriaCombo.getSelectedItem().toString();
            if(criterion.equals("Titolo")){
                if (!searchText.isEmpty() && !searchText.equals("Search")) {
                    List<Book> searchResults = db.findBookByTitle(searchText, this.currentSortCriteria);
                    booksPanelUI.displayBooks(searchResults);
                } else {
                    booksPanelUI.displayBooks(db.getAllBook(this.currentSortCriteria));
                }
            }else {
                if (!searchText.isEmpty() && !searchText.equals("Search")) {
                    List<Book> searchResults = db.findBookByAuthor(searchText, this.currentSortCriteria);
                    booksPanelUI.displayBooks(searchResults);
                } else {
                    booksPanelUI.displayBooks(db.getAllBook(this.currentSortCriteria));
                }
            }
        });
        return rightPanel;
    }

    private JPanel inizializzaSezioneSX(){
        JPanel leftPanel = new JPanel();
        leftPanel.setLayout(new BorderLayout());
        leftPanel.setPreferredSize(new Dimension(200, 0));
        leftPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Titolo programma sopra i bottoni
        JLabel TextLabel = new JLabel("Gestore Libreria");
        TextLabel.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 0));
        TextLabel.setFont(new Font("SansSerif", Font.BOLD, 20));

        // Proprietà dei bottoni
        JPanel StatoBottoni = new JPanel();
        StatoBottoni.setLayout(new BoxLayout(StatoBottoni, BoxLayout.Y_AXIS));
        StatoBottoni.setBorder(BorderFactory.createEmptyBorder(10, 0, 10, 0));

        JButton AllBtn = new JButton("All");
        JButton lettiBtn = new JButton("Letti");
        JButton inLetturaBtn = new JButton("In lettura");
        JButton daLeggereBtn = new JButton("Da leggere");

        Dimension buttonSize = new Dimension(160, 35);
        Color selectedColor = new Color(53, 53, 53);
        Color defaultColor = new Color(30, 30, 30);

        //JButton[] stateButtons = {AllBtn,lettiBtn, inLetturaBtn, daLeggereBtn};

        List<JButton> stateButtons = new ArrayList<>();
        stateButtons.add(AllBtn);
        stateButtons.add(lettiBtn);
        stateButtons.add(inLetturaBtn);
        stateButtons.add(daLeggereBtn);

        for (JButton btn : stateButtons) {
            btn.setPreferredSize(buttonSize);
            btn.setMinimumSize(buttonSize);
            btn.setMaximumSize(buttonSize);
            btn.setBackground(defaultColor);
            btn.setFocusPainted(false);
            btn.setOpaque(true);
            btn.setBorderPainted(false);
            btn.setHorizontalAlignment(SwingConstants.LEFT);
            btn.setMargin(new Insets(0, 10, 0, 0));
            StatoBottoni.add(btn);
        }

        AllBtn.addActionListener(e -> {
            booksPanelUI.displayBooks(db.getAllBook(this.currentSortCriteria)); // Mostra tutti i libri
            highlightButton(AllBtn, stateButtons, selectedColor, defaultColor); // Evidenzia il bottone
        });

        lettiBtn.addActionListener(e -> {
            booksPanelUI.displayBooks(db.filterBookByReadingState("LETTO", this.currentSortCriteria)); // Filtra per "LETTO"
            highlightButton(lettiBtn, stateButtons, selectedColor, defaultColor);
        });

        inLetturaBtn.addActionListener(e -> {
            booksPanelUI.displayBooks(db.filterBookByReadingState("IN LETTURA", this.currentSortCriteria)); // Filtra per "IN LETTURA"
            highlightButton(inLetturaBtn, stateButtons, selectedColor, defaultColor);
        });

        daLeggereBtn.addActionListener(e -> {
            booksPanelUI.displayBooks(db.filterBookByReadingState("DA LEGGERE", this.currentSortCriteria)); // Filtra per "DA LEGGERE"
            highlightButton(daLeggereBtn, stateButtons, selectedColor, defaultColor);
        });

        // Imposta il bottone "Tutti i Libri" come selezionato di default all'avvio
        highlightButton(AllBtn, stateButtons, selectedColor, defaultColor);

//        JLabel ratingLabel = new JLabel();
//        StatoBottoni.add(ratingLabel);

        JPanel ratingPanel = new JPanel(); // Pannello per le "stelline"
        ratingPanel.setLayout(new FlowLayout(FlowLayout.LEFT)); // Allineamento a sinistra

        for (int i = 1; i <= 5; i++) {
            JButton starButton = new JButton("★");
            starButton.setFont(starButton.getFont().deriveFont(16f));
            starButton.setForeground(Color.ORANGE);
            starButton.setBackground(new Color(30, 30, 30));
            starButton.setFocusPainted(false);
            starButton.setBorderPainted(false);
            starButton.setOpaque(true);
            starButton.setMargin(new Insets(0, 0, 0, 0));

            final int currentRating = i; // Per l'uso nella lambda
            starButton.addActionListener(e -> {
                booksPanelUI.displayBooks(db.filterBookByRating(currentRating, this.currentSortCriteria));
                highlightButton(starButton, stateButtons, selectedColor, defaultColor); // Evidenzia la stella
            });
            ratingPanel.add(starButton);
            stateButtons.add(starButton); // Aggiungi il bottone alla lista
        }
        leftPanel.add(ratingPanel);
        //titolo applicazione
        JPanel titlePanel = new JPanel(new BorderLayout());
        titlePanel.add(TextLabel, BorderLayout.NORTH);
        titlePanel.add(StatoBottoni, BorderLayout.CENTER);

        //Bottone addBook
        JButton addBookBtn = addBookButton();

        JPanel bottomLeftPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        bottomLeftPanel.add(addBookBtn);
        leftPanel.add(titlePanel, BorderLayout.NORTH);
        leftPanel.add(bottomLeftPanel, BorderLayout.SOUTH);

        return leftPanel;

    }

    private void highlightButton(JButton selectedButton, List<JButton> buttons, Color selectedColor, Color defaultColor) {
        for (JButton btn : buttons) {
            btn.setBackground(defaultColor);
        }
        selectedButton.setBackground(selectedColor);
    }

    private JButton addBookButton(){
        JButton addBookBtn = new JButton("Aggiungi libro");
        addBookBtn.setBackground(new Color(30, 144, 255)); // Blu
        addBookBtn.setForeground(Color.WHITE);

        //logica per il pannello per aggiungere un libro
        addBookBtn.addActionListener(e -> {
            JTextField titoloField = new JTextField(20);
            JTextField autoreField = new JTextField(20);
            JTextField isbnField = new JTextField(20);
            JTextField genreField = new JTextField(20);
            JSpinner ratingSpinner = new JSpinner(new SpinnerNumberModel(1, 1, 5, 1));
            JComboBox<String> statoCombo = new JComboBox<>(new String[]{"letto", "in lettura", "da leggere"});
            JTextField imagePathField = new JTextField(15);
            imagePathField.setEditable(false);
            JButton browseBtn = new JButton("Sfoglia");

            //Immagine di copertina
            JLabel imagePreview = new JLabel();
            int width = 120;
            int height = 180;
            imagePreview.setPreferredSize(new Dimension(width, height));

            ImageIcon placeholder = loadPlaceholderImage(width, height);
            if (placeholder != null) {
                imagePreview.setIcon(placeholder);
            } else {
                imagePreview.setText("Immagine non disponibile");
            }


            JPanel imageWrapper = new JPanel();
            imageWrapper.setLayout(new BorderLayout());
            imageWrapper.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 20));
            imageWrapper.add(imagePreview, BorderLayout.CENTER);


            //comportamento tasto sfoglia
            browseButtonAction(browseBtn, imagePathField, imagePreview, width, height);

            JPanel panel = new JPanel();
            panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
            panel.add(new JLabel("Titolo*:"));
            panel.add(titoloField);
            panel.add(new JLabel("Autore*:"));
            panel.add(autoreField);
            panel.add(new JLabel("Genere:"));
            panel.add(genreField);
            panel.add(new JLabel("ISBN:"));
            panel.add(isbnField);
            panel.add(new JLabel("Rating (1-5):"));
            panel.add(ratingSpinner);
            panel.add(new JLabel("Stato lettura:"));
            panel.add(statoCombo);
            panel.add(new JLabel("Copertina:"));
            JPanel filePanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
            filePanel.add(imagePathField);
            filePanel.add(browseBtn);
            panel.add(filePanel);

            // Layout generale
            JPanel BookPanel = new JPanel(new BorderLayout());
            BookPanel.add(panel, BorderLayout.CENTER);
            BookPanel.add(imageWrapper, BorderLayout.NORTH);
            imageWrapper.setLayout(new FlowLayout(FlowLayout.CENTER));


            int result = JOptionPane.showConfirmDialog(null, BookPanel, "Nuovo libro", JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);
            if (result == JOptionPane.OK_OPTION) {
                String titolo = titoloField.getText().trim();
                String autore = autoreField.getText().trim();
                String isbn = isbnField.getText().trim();
                String genre = genreField.getText().trim();
                int rating = (Integer) ratingSpinner.getValue();
                String stato = (String) statoCombo.getSelectedItem();
                String path = "/images/image_placeholder.png";
                if(!imagePathField.getText().trim().isEmpty()){
                    path = imagePathField.getText().trim();
                }

                if (!titolo.isEmpty() && !autore.isEmpty()) {
                    Book nuovoLibro = new Book.Builder(titolo, autore).isbn(isbn)
                            .rating(rating)
                            .readingState(stato)
                            .coverPath(path)
                            .genre(genre)
                            .build();
                    System.out.println("Creato libro: " + nuovoLibro.toString());
                    db.addBook(nuovoLibro);
                } else {
                    JOptionPane.showMessageDialog(null, "Titolo e autore sono obbligatori.");
                }
            }
        });
        return addBookBtn;
    }

    public static ImageIcon loadPlaceholderImage(int width, int height) {
        try {
            java.io.InputStream imageStream = GestoreLibreriaUI.class.getResourceAsStream("/images/image_placeholder.png");
            if (imageStream != null) {
                ImageIcon icon = new ImageIcon(javax.imageio.ImageIO.read(imageStream));
                Image scaled = icon.getImage().getScaledInstance(width, height, Image.SCALE_SMOOTH);
                return new ImageIcon(scaled);
            } else {
                System.err.println("Immagine placeholder non trovata nel JAR");
                return null;
            }
        } catch (Exception e) {
            System.err.println("Errore nel caricamento dell'immagine placeholder: " + e.getMessage());
            return null;
        }
    }

    private void browseButtonAction(JButton browseBtn, JTextField imagePathField, JLabel imagePreview, int width, int height){
        browseBtn.addActionListener(ev -> {
            JFileChooser fileChooser = new JFileChooser();
            int result = fileChooser.showOpenDialog(null);
            if (result == JFileChooser.APPROVE_OPTION) {
                File selectedFile = fileChooser.getSelectedFile();
                imagePathField.setText(fileChooser.getSelectedFile().getAbsolutePath());

                ImageIcon selectedIcon = loadAndScaleImage(selectedFile.getAbsolutePath(), width, height);
                if (selectedIcon != null) {
                    imagePreview.setIcon(selectedIcon); // sostituisce il placeholder
                } else {
                    JOptionPane.showMessageDialog(null, "Impossibile caricare l'immagine.");
                }
            }
        });
    }

    public static ImageIcon loadAndScaleImage(String path, int width, int height) {
        try {
            // Se è un percorso delle risorse, carica dal JAR
            if (path != null && (path.startsWith("/images/") || path.equals("/images/image_placeholder.png"))) {
                java.io.InputStream imageStream = GestoreLibreriaUI.class.getResourceAsStream(path);
                if (imageStream != null) {
                    ImageIcon icon = new ImageIcon(javax.imageio.ImageIO.read(imageStream));
                    Image scaled = icon.getImage().getScaledInstance(width, height, Image.SCALE_SMOOTH);
                    return new ImageIcon(scaled);
                }
            }

            // Altrimenti, carica come file esterno
            if (path != null && !path.isEmpty()) {
                ImageIcon icon = new ImageIcon(path);
                if (icon.getIconWidth() > 0) {
                    Image scaled = icon.getImage().getScaledInstance(width, height, Image.SCALE_SMOOTH);
                    return new ImageIcon(scaled);
                }
            }

            return null;
        } catch (Exception e) {
            System.err.println("Errore nel caricamento immagine da: " + path + ". " + e.getMessage());
            return null;
        }
    }

    public static void main(String[] args) {
        try{
            UIManager.setLookAndFeel(new FlatMacDarkLaf());
        } catch (UnsupportedLookAndFeelException e) {
            System.err.println("Impossibile caricare FlatLaf");
        }
        BookRepositoryImplementor repo = new SQLiteBookRepository();
        ConcreteBookManager db = new ConcreteBookManager(repo);
        SwingUtilities.invokeLater(() -> {
            GestoreLibreriaUI UI = new GestoreLibreriaUI(db);
            UI.setVisible(true);
        });
    }

}

// ---- Fine: ./ui/GestoreLibreriaUI.java ----
